from django.db import models
from django.utils import timezone
import uuid
import json
from transaction_monitoring.model.account import Account
from transaction_monitoring.model.customer import Customer
from transaction_monitoring.model.transaction import Transactions
from transaction_monitoring.model.rule_settings import AMLRules


class Alert(models.Model):
    """
    Unified model for alerts generated by any rule type.
    Designed to be flexible enough to handle all types of AML alerts.
    """
    alert_id = models.CharField(max_length=64, primary_key=True)
    alert_date = models.DateField(default=timezone.now)
    alert_timestamp = models.DateTimeField(default=timezone.now)
    
    # Alert classification
    rule = models.ForeignKey(
        AMLRules,
        on_delete=models.SET_NULL,
        null=True,
        related_name='generated_alerts'
    )
    rule_type = models.CharField(max_length=50, db_index=True)
    rule_code = models.CharField(max_length=100, db_index=True)
    
    alert_score = models.IntegerField(default=0)
    alert_level = models.CharField(
        max_length=20, 
        choices=[
            ('LOW', 'Low'),
            ('MEDIUM', 'Medium'),
        ('HIGH', 'High'),
            ('CRITICAL', 'Critical'),
        ],
        default='MEDIUM',
        db_index=True
    )
    
    # Account information
    primary_account = models.ForeignKey(
        Account,
        on_delete=models.SET_NULL,
        null=True,
        related_name='primary_alerts'
    )
    primary_account_number = models.CharField(max_length=64, db_index=True)
    account_type = models.CharField(max_length=50, null=True, blank=True)
    
    # Customer information
    primary_customer = models.ForeignKey(
        Customer,
        on_delete=models.SET_NULL,
        null=True,
        related_name='primary_alerts'
    )
    primary_customer_number = models.CharField(max_length=64, db_index=True)
    primary_customer_name = models.CharField(max_length=255, null=True, blank=True)
    customer_risk_level = models.CharField(max_length=20, null=True, blank=True)
    
    # Trigger information
    triggering_transaction = models.ForeignKey(
        Transactions,
        on_delete=models.SET_NULL,
        null=True,
        related_name='triggered_alerts'
    )
    
    # Summary metrics
    total_amount = models.DecimalField(max_digits=20, decimal_places=2, default=0)
    transaction_count = models.IntegerField(default=1)
    currency_code = models.CharField(max_length=10, null=True, blank=True)
    
    # Time period of activity
    activity_start_date = models.DateField(null=True, blank=True)
    activity_end_date = models.DateField(null=True, blank=True)
    
    # Risk flags
    involves_high_risk_country = models.BooleanField(default=False)
    involves_high_risk_party = models.BooleanField(default=False)
    involves_high_risk_transaction_type = models.BooleanField(default=False)
    involves_cash = models.BooleanField(default=False)
    involves_dormant_account = models.BooleanField(default=False)
    
    # Alert status and workflow
    status = models.CharField(
        max_length=50,
        choices=[
            ('NEW', 'New'),
            ('ASSIGNED', 'Assigned for Review'),
            ('INVESTIGATING', 'Under Investigation'),
            ('FALSE_POSITIVE', 'Closed - False Positive'),
            ('LEGITIMATE', 'Closed - Legitimate Activity'),
            ('SUSPICIOUS', 'Closed - Suspicious Activity'),
            ('SAR_FILED', 'SAR Filed'),
        ],
        default='NEW',
        db_index=True
    )
    assigned_to = models.CharField(max_length=100, null=True, blank=True)
    assigned_date = models.DateTimeField(null=True, blank=True)
    
    # Reason for alert
    alert_title = models.CharField(max_length=255)
    alert_summary = models.TextField()
    alert_details = models.TextField(null=True, blank=True)
    
    # Review information
    review_notes = models.TextField(null=True, blank=True)
    reviewed_by = models.CharField(max_length=100, null=True, blank=True)
    reviewed_date = models.DateTimeField(null=True, blank=True)
    
    # Outcome
    close_reason = models.CharField(max_length=255, null=True, blank=True)
    resolution_date = models.DateTimeField(null=True, blank=True)
    resolution_action = models.CharField(max_length=255, null=True, blank=True)
    sar_reference = models.CharField(max_length=100, null=True, blank=True)
    
    # Rule-specific data (extensible to any rule type)
    # Stored as JSON to allow flexibility without schema changes for new rule types
    rule_specific_data = models.JSONField(default=dict, blank=True)
    
    # Book-keeping
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        db_table = 'aml_alerts'
        indexes = [
            models.Index(fields=['alert_date']),
            models.Index(fields=['rule_type']),
            models.Index(fields=['rule_code']),
            models.Index(fields=['primary_account_number']),
            models.Index(fields=['primary_customer_number']),
            models.Index(fields=['status']),
            models.Index(fields=['alert_level']),
            models.Index(fields=['assigned_to']),
        ]
        ordering = ['-alert_date', '-alert_score']
    
    def __str__(self):
        return f"Alert {self.alert_id} - {self.rule_type} - {self.status}"
    
    def save(self, *args, **kwargs):
        if not self.alert_id:
            self.alert_id = str(uuid.uuid4())
        
        # Ensure rule_type and rule_code are set if rule is provided
        if self.rule and not self.rule_type:
            self.rule_type = self.rule.rule_type or "UNKNOWN"
        if self.rule and not self.rule_code:
            self.rule_code = self.rule.rule_code
        
        # Set activity dates if not already set
        if self.triggering_transaction and not self.activity_start_date:
            self.activity_start_date = self.triggering_transaction.transaction_date
            self.activity_end_date = self.triggering_transaction.transaction_date
        
        super().save(*args, **kwargs)
    
    # Get rule-specific data (with type handling)
    def get_rule_data(self, key, default=None):
        """Get data from rule_specific_data with proper type handling"""
        if not self.rule_specific_data:
            return default
        return self.rule_specific_data.get(key, default)
    
    # Add rule-specific data
    def set_rule_data(self, key, value):
        """Set data in rule_specific_data"""
        if not self.rule_specific_data:
            self.rule_specific_data = {}
        self.rule_specific_data[key] = value
    
    # Helper methods for dormant account alerts
    def set_dormant_account_data(self, dormancy_days, dormancy_start_date):
        """Set dormant account specific data"""
        data = {
            'dormancy_duration_days': dormancy_days,
            'dormancy_start_date': dormancy_start_date.isoformat() if dormancy_start_date else None,
        }
        self.rule_specific_data.update(data)
        self.involves_dormant_account = True
    
    # Helper methods for large cash transaction alerts
    def set_large_cash_data(self, aggregation_period_days, transaction_types):
        """Set large cash transaction specific data"""
        data = {
            'aggregation_period_days': aggregation_period_days,
            'transaction_types': transaction_types,
        }
        self.rule_specific_data.update(data)
        self.involves_cash = True
    
    # Alert workflow methods
    def assign_to_reviewer(self, reviewer_name):
        """Assign this alert to a reviewer"""
        self.status = 'ASSIGNED'
        self.assigned_to = reviewer_name
        self.assigned_date = timezone.now()
        self.save(update_fields=['status', 'assigned_to', 'assigned_date', 'updated_at'])
    
    def mark_as_investigating(self, notes=None):
        """Mark this alert as under investigation"""
        self.status = 'INVESTIGATING'
        if notes:
            self.review_notes = (self.review_notes or '') + f"\n[{timezone.now()}] Investigation started: {notes}"
        self.save(update_fields=['status', 'review_notes', 'updated_at'])
    
    def close_as_false_positive(self, reviewer, reason, notes=None):
        """Close this alert as a false positive"""
        self.status = 'FALSE_POSITIVE'
        self.reviewed_by = reviewer
        self.reviewed_date = timezone.now()
        self.close_reason = reason
        self.resolution_date = timezone.now()
        
        if notes:
            self.review_notes = (self.review_notes or '') + f"\n[{timezone.now()}] Closed as false positive: {notes}"
        
        self.save(update_fields=[
            'status', 'reviewed_by', 'reviewed_date', 'close_reason',
            'resolution_date', 'review_notes', 'updated_at'
        ])
    
    def close_as_legitimate(self, reviewer, reason, notes=None):
        """Close this alert as legitimate activity"""
        self.status = 'LEGITIMATE'
        self.reviewed_by = reviewer
        self.reviewed_date = timezone.now()
        self.close_reason = reason
        self.resolution_date = timezone.now()
        
        if notes:
            self.review_notes = (self.review_notes or '') + f"\n[{timezone.now()}] Closed as legitimate: {notes}"
        
        self.save(update_fields=[
            'status', 'reviewed_by', 'reviewed_date', 'close_reason',
            'resolution_date', 'review_notes', 'updated_at'
        ])
    
    def mark_as_suspicious(self, reviewer, notes=None):
        """Mark this alert as suspicious activity"""
        self.status = 'SUSPICIOUS'
        self.reviewed_by = reviewer
        self.reviewed_date = timezone.now()
        
        if notes:
            self.review_notes = (self.review_notes or '') + f"\n[{timezone.now()}] Marked as suspicious: {notes}"
        
        self.save(update_fields=[
            'status', 'reviewed_by', 'reviewed_date', 'review_notes', 'updated_at'
        ])
    
    def mark_sar_filed(self, reviewer, sar_reference, notes=None):
        """Mark this alert as having a SAR filed"""
        self.status = 'SAR_FILED'
        self.reviewed_by = reviewer
        self.reviewed_date = timezone.now()
        self.sar_reference = sar_reference
        self.resolution_date = timezone.now()
        
        if notes:
            self.review_notes = (self.review_notes or '') + f"\n[{timezone.now()}] SAR filed: {notes}"
        
        self.save(update_fields=[
            'status', 'reviewed_by', 'reviewed_date', 'sar_reference',
            'resolution_date', 'review_notes', 'updated_at'
        ])


class RelatedEntity(models.Model):
    """
    Model for tracking entities (transactions, accounts, customers) related to an alert.
    Replaces the specific RelatedTransaction model with a more flexible approach.
    """
    id = models.AutoField(primary_key=True)
    alert = models.ForeignKey(Alert, on_delete=models.CASCADE, related_name='related_entities')
    
    # Entity type
    entity_type = models.CharField(
        max_length=20,
        choices=[
            ('TRANSACTION', 'Transaction'),
            ('ACCOUNT', 'Account'),
            ('CUSTOMER', 'Customer'),
            ('OTHER', 'Other Entity'),
        ]
    )
    
    # Entity references - only one of these should be populated based on entity_type
    transaction = models.ForeignKey(Transactions, on_delete=models.CASCADE, null=True, blank=True, related_name='related_to_alerts')
    account = models.ForeignKey(Account, on_delete=models.CASCADE, null=True, blank=True, related_name='related_to_alerts')
    customer = models.ForeignKey(Customer, on_delete=models.CASCADE, null=True, blank=True, related_name='related_to_alerts')
    
    # For other entity types or to store an entity ID as a string
    entity_id = models.CharField(max_length=100, null=True, blank=True)
    entity_description = models.CharField(max_length=255, null=True, blank=True)
    
    # Relationship information
    is_primary = models.BooleanField(default=False, help_text="True if this is the primary entity that triggered the alert")
    relationship_type = models.CharField(
        max_length=50,
        choices=[
            ('TRIGGER', 'Triggering Entity'),
            ('SAME_ACCOUNT', 'Same Account'),
            ('SAME_CUSTOMER', 'Same Customer'),
            ('COUNTERPARTY', 'Counterparty'),
            ('LINKED_ACCOUNT', 'Linked Account'),
            ('BENEFICIARY', 'Beneficiary'),
            ('ORIGINATOR', 'Originator'),
            ('PATTERN', 'Part of Pattern'),
            ('OTHER', 'Other Relationship'),
        ],
        default='OTHER'
    )
    
    # Additional data
    additional_data = models.JSONField(default=dict, blank=True)
    
    # Book-keeping
    created_at = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        db_table = 'alert_related_entities'
        unique_together = (
            ('alert', 'entity_type', 'transaction'),
            ('alert', 'entity_type', 'account'),
            ('alert', 'entity_type', 'customer'),
            ('alert', 'entity_type', 'entity_id'),
        )
        indexes = [
            models.Index(fields=['entity_type']),
            models.Index(fields=['is_primary']),
            models.Index(fields=['relationship_type']),
        ]
    
    def __str__(self):
        if self.entity_type == 'TRANSACTION' and self.transaction:
            return f"Transaction {self.transaction.transaction_id} - {self.get_relationship_type_display()}"
        elif self.entity_type == 'ACCOUNT' and self.account:
            return f"Account {self.account.account_number} - {self.get_relationship_type_display()}"
        elif self.entity_type == 'CUSTOMER' and self.customer:
            return f"Customer {self.customer.customer_number} - {self.get_relationship_type_display()}"
        else:
            return f"{self.entity_type} {self.entity_id} - {self.get_relationship_type_display()}"


class SuspiciousActivityReport(models.Model):
    """
    Model representing a Suspicious Activity Report (SAR) filed with regulatory authorities.
    Multiple alerts can be associated with a single SAR.
    """
    sar_id = models.CharField(max_length=64, primary_key=True)
    sar_reference = models.CharField(max_length=100, unique=True)
    filing_date = models.DateField()
    
    # SAR details
    report_type = models.CharField(
        max_length=50,
        choices=[
            ('INITIAL', 'Initial Report'),
            ('CONTINUING', 'Continuing Activity'),
            ('CORRECTED', 'Corrected Report'),
        ],
        default='INITIAL'
    )
    
    # Related entities
    primary_subject = models.ForeignKey(Customer, on_delete=models.SET_NULL, null=True, related_name='sars_as_subject')
    primary_account = models.ForeignKey(Account, on_delete=models.SET_NULL, null=True, related_name='associated_sars')
    
    # Suspicious activity details
    activity_start_date = models.DateField()
    activity_end_date = models.DateField()
    total_amount = models.DecimalField(max_digits=20, decimal_places=2)
    currency_code = models.CharField(max_length=10)
    
    # Characterization
    suspicious_activity_types = models.CharField(max_length=255)
    narrative_summary = models.TextField()
    
    # Status
    status = models.CharField(
        max_length=20,
        choices=[
            ('DRAFT', 'Draft'),
            ('FILED', 'Filed'),
            ('ACKNOWLEDGED', 'Acknowledged'),
            ('AMENDED', 'Amended'),
        ],
        default='DRAFT'
    )
    
    # Filing details
    filing_user = models.CharField(max_length=100)
    acknowledgment_date = models.DateField(null=True, blank=True)
    acknowledgment_reference = models.CharField(max_length=100, null=True, blank=True)
    
    # Book-keeping
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        db_table = 'tm_suspicious_activity_reports'
        ordering = ['-filing_date']
    
    def __str__(self):
        return f"SAR {self.sar_reference} - {self.get_status_display()}"
    
    def save(self, *args, **kwargs):
        if not self.sar_id:
            self.sar_id = str(uuid.uuid4())
        super().save(*args, **kwargs)


class AlertSARRelationship(models.Model):
    """
    Model tracking the relationship between alerts and SARs.
    Multiple alerts can be included in a single SAR.
    """
    id = models.AutoField(primary_key=True)
    alert = models.ForeignKey(Alert, on_delete=models.CASCADE, related_name='sar_relationships')
    sar = models.ForeignKey(SuspiciousActivityReport, on_delete=models.CASCADE, related_name='alert_relationships')
    
    # Relationship attributes
    is_primary_reason = models.BooleanField(default=False, help_text="True if this alert is the primary reason for filing the SAR")
    included_in_narrative = models.BooleanField(default=True)
    inclusion_notes = models.TextField(null=True, blank=True)
    
    # Book-keeping
    created_at = models.DateTimeField(auto_now_add=True)
    created_by = models.CharField(max_length=100, null=True, blank=True)
    
    class Meta:
        db_table = 'alert_sar_relationships'
        unique_together = ('alert', 'sar')
    
    def __str__(self):
        return f"Alert {self.alert.alert_id} ↔ SAR {self.sar.sar_reference}"
